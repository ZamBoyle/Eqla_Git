[:arrow_left: Revenir au sommaire.](../README.md#sommaire)

<h1 style="text-align:center">Formation Git</h1>
<h2>Table des matières</h2>  


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1. Introduction](#1-introduction)
- [2. Git c'est quoi ?](#2-git-cest-quoi-)
- [3. Installation de Git</h2>](#3-installation-de-gith2)
  - [3.1 Windows](#31-windows)
    - [3.1.1 Téléchargement](#311-téléchargement)
    - [3.1.2 Installation](#312-installation)
  - [3.2 Mac Os](#32-mac-os)
  - [3.3 Linux - via apt (Debian, Ubuntu, Raspberry Pi OS)](#33-linux---via-apt-debian-ubuntu-raspberry-pi-os)
- [4. Nouveau Windows Terminal](#4-nouveau-windows-terminal)
  - [4.1 Installation](#41-installation)
  - [4.2 Lancement du terminal](#42-lancement-du-terminal)
  - [4.3 Changer le terminal par défaut](#43-changer-le-terminal-par-défaut)
  - [4.4 Nouvel onglet](#44-nouvel-onglet)
  - [4.5 Naviguer entre onglets](#45-naviguer-entre-onglets)
- [5. Utiliser la ligne de commandes](#5-utiliser-la-ligne-de-commandes)
  - [5.1 Connaître le répertoire courant](#51-connaître-le-répertoire-courant)
  - [5.2 Lister les fichiers](#52-lister-les-fichiers)
  - [5.3 Créer un répertoire](#53-créer-un-répertoire)
  - [5.4 Changer de répertoire](#54-changer-de-répertoire)
  - [5.5 Supprimer un répertoire](#55-supprimer-un-répertoire)
  - [5.6 Supprimer un fichier](#56-supprimer-un-fichier)
  - [5.7 Renommer un fichier/répertoire](#57-renommer-un-fichierrépertoire)
  - [5.8 Afficher le contenu d'un fichier](#58-afficher-le-contenu-dun-fichier)
  - [5.9 Créer un fichier avec un contenu vide](#59-créer-un-fichier-avec-un-contenu-vide)
  - [5.10 Les redirections des commandes > et >>](#510-les-redirections-des-commandes--et-)
  - [5.11 Rediriger la sortie d'une commande vers un programme](#511-rediriger-la-sortie-dune-commande-vers-un-programme)
    - [5.11.1 dans le programme clip: le presse papier](#5111-dans-le-programme-clip-le-presse-papier)
    - [5.11.2 dans vscode](#5112-dans-vscode)
  - [5.12 Customiser son prompt](#512-customiser-son-prompt)
- [6. Qu'est-ce qu'un dépôt/repository Git ?](#6-quest-ce-quun-dépôtrepository-git-)
- [7.	Répertoire courant vs la zone d'indexation vs dépôt](#7-répertoire-courant-vs-la-zone-dindexation-vs-dépôt)
- [8. Chronologie des actions avant que vos modifications fassent partie de votre dépôt](#8-chronologie-des-actions-avant-que-vos-modifications-fassent-partie-de-votre-dépôt)
- [9. Configurer les informations de l'utilisateur pour tous les dépôts locaux](#9-configurer-les-informations-de-lutilisateur-pour-tous-les-dépôts-locaux)
- [10. Création de notre premier dépôt local](#10-création-de-notre-premier-dépôt-local)
- [11. Status de notre dépôt](#11-status-de-notre-dépôt)
- [12. Ajouter un fichier](#12-ajouter-un-fichier)
- [13. Indexer/désindexer ses modifications](#13-indexerdésindexer-ses-modifications)
  - [13.1 Indexer un fichier](#131-indexer-un-fichier)
  - [13.2 Désindexer un fichier](#132-désindexer-un-fichier)
  - [13.3 Indexer plusieurs fichiers](#133-indexer-plusieurs-fichiers)
  - [13.4 Indexer des fichiers supprimés](#134-indexer-des-fichiers-supprimés)
- [14. Notre premier commit](#14-notre-premier-commit)
- [16. Voyage dans l'historique d'un dépôt](#16-voyage-dans-lhistorique-dun-dépôt)
- [17. Naviguer dans l'historique de notre dépôt](#17-naviguer-dans-lhistorique-de-notre-dépôt)
- [18. Les tags](#18-les-tags)
- [19. Le modèle distribué](#19-le-modèle-distribué)
- [20. GitHub](#20-github)
- [21. Cloner un dépôt hébergé sur GitHub avec la commande git clone](#21-cloner-un-dépôt-hébergé-sur-github-avec-la-commande-git-clone)
- [22. Présentation de la commande gh](#22-présentation-de-la-commande-gh)
- [23. Installation de gh](#23-installation-de-gh)
  - [23.1 Windows](#231-windows)
  - [23.2 Mac Os](#232-mac-os)
  - [23.3 Ubuntu](#233-ubuntu)
- [24. Authentification sur GitHub via gh](#24-authentification-sur-github-via-gh)
- [25. Creation d'un gist public](#25-creation-dun-gist-public)
- [26. Cloner un dépôt hébergé sur GitHub avec la commande gh repo clone](#26-cloner-un-dépôt-hébergé-sur-github-avec-la-commande-gh-repo-clone)
- [27. Créer un dépôt sur GitHub](#27-créer-un-dépôt-sur-github)
- [28. Le fichier .gitignore](#28-le-fichier-gitignore)
- [29. Token de connexion](#29-token-de-connexion)
  - [29.1 Création du token](#291-création-du-token)
  - [29.2 Enregistrer le token globalement](#292-enregistrer-le-token-globalement)
  - [29.3 désenregistrer le token globalement](#293-désenregistrer-le-token-globalement)
- [30. Git Push : Envoyer vos lettres au monde](#30-git-push--envoyer-vos-lettres-au-monde)
  - [30.1. Git Push : Déposer vos lettres à la poste](#301-git-push--déposer-vos-lettres-à-la-poste)
  - [30.2. Pourquoi utiliser Git Push ?](#302-pourquoi-utiliser-git-push-)
- [31. Ajouter un dépôt local sur GitHub](#31-ajouter-un-dépôt-local-sur-github)
  - [31.1 Via gh](#311-via-gh)
  - [31.2 Via Git](#312-via-git)
  - [31.3 Exemple pratique](#313-exemple-pratique)
- [32. Git Pull et Git Fetch : Une Exploration](#32-git-pull-et-git-fetch--une-exploration)
  - [32.1. Git Fetch : Vérifier le courrier](#321-git-fetch--vérifier-le-courrier)
  - [32.2. Git Pull : Récupérer le courrier](#322-git-pull--récupérer-le-courrier)
- [33. Pousser ses tags sur Github](#33-pousser-ses-tags-sur-github)
- [34. Les issues](#34-les-issues)
- [35. Git blame - Informations de modifications d'un fichier](#35-git-blame---informations-de-modifications-dun-fichier)
- [36. Git stash: garder des modifications non commitées](#36-git-stash-garder-des-modifications-non-commitées)
  - [36.1. Introduction](#361-introduction)
  - [36.2. Pour simplifier](#362-pour-simplifier)
- [37. Faire un git pull avec une modification en local et distante](#37-faire-un-git-pull-avec-une-modification-en-local-et-distante)
- [38. Modifications conflictuelles](#38-modifications-conflictuelles)
- [39. Github - Le format Markdown](#39-github---le-format-markdown)
  - [39.1 Le fichier README.md](#391-le-fichier-readmemd)
  - [39.1 Mettre un titre h1](#391-mettre-un-titre-h1)
  - [39.2 Afficher du code](#392-afficher-du-code)
  - [39.3 Mettre en gras](#393-mettre-en-gras)
  - [39.4 Mettre en italic](#394-mettre-en-italic)
  - [39.5 Liens hypertextes](#395-liens-hypertextes)
  - [39.6 Les tableaux](#396-les-tableaux)
- [40. Les GitHub Pages](#40-les-github-pages)
  - [40.1 Créons le dépôt sur GitHub:](#401-créons-le-dépôt-sur-github)
  - [40.1 Créons un dépôt local et poussons-le sur GitHub:](#401-créons-un-dépôt-local-et-poussons-le-sur-github)
  - [40.2 Poussons un dépôt existant depuis la ligne de commande:](#402-poussons-un-dépôt-existant-depuis-la-ligne-de-commande)

<!-- /code_chunk_output -->



## 1. Introduction

Nous allons illustrer l'utilité de [Git](https://git-scm.com/) dans la pratique de votre futur métier via deux exemples:

- Le premier: Imaginez qu'un client vous demande de faire un site de ventes en ligne : vous le faites et il fonctionne nickel.

   Pendant la période de Noël, il vous demande de faire de grosses modifications et bardaf, il ne fonctionne plus du tout : erreur 500… Le client vous demandera de remettre immédiatement le site à l'état précédent les modifications problématiques pour ne pas perdre trop de ventes en cette période très lucrative pour lui.

   Si vous n'aviez pas un backup de la précédente version ou un système de gestion de l'historique des modifications, vous risquez d'être bien embêté…
   
   C'est ici qu'entre en scène l'outil git.

- Le second: vous devez travailler sur un projet à plusieurs mais vous ne savez pas comment faire pour collaborer de manière efficace avec vos collègues pour la gestion du code et voir comment gérer/fusionner le travail fait par chacun.
C'est ici qu'entre en scène git via l'intermédiaire d'outils comme [GitHub](https://github.com/), [Gitlab](https://gitlab.com/), etc.
- Le dernier: ce cours. Je vous l'ai envoyé par email et partagé dans un Google Drive. Cependant, si je modifie ce cours comme je le fais en ce moment, vous n'aurez pas la dernière version. Il faudra que je vous l'envoie à nouveau par email et que je remette ce document sur le Drive. Alors qu'avec l'utilisation de Git et GitHub se problème de dernière version est facilement géré.

## 2. Git c'est quoi ?

Git a été créé en 2005 par le papa de Linux (1991) : Linus Torvalds pour le développement du noyau Linux. Il permet de faire le suivi des différentes modifications d'un projet et de revenir dans un état précédent. Et surtout, il permet de travailler à plusieurs sur un même projet.

Auparavant, les développeurs utilisaient Bitkeeper de la société Bitmover qui concédait une licence gratuite d'utilisation au développement du noyau Linux. Mais un développeur du Noyau commença a créé un client opensource pour accéder à Bitkeeper. Ce qui provoqua après de longues négociations la suppression de la licence gratuite aux développeurs du noyau Linux. Réaction que l'on peut comprendre dans l'absolu... C'est pourquoi Linus Torvalds coda Git pour éviter tout futurs problèmes de licence d'utilisation. Ce qui devait sans doute arriver tôt ou tard car les puristes du logiciel libres dont le grand gourou du logiciel libre Richard Stallman prônait depuis longtemps qu'il n'était pas acceptable que le noyau Linux utilise un logiciel propriétaire pour la gestion de son code source.

Git est le logiciel de versions le plus populaire, utilisé par plus de 56.000.000 de développeurs dans le monde. Il est un incontournable des grandes sociétés de logiciel. Grandement utilisé dans le développement de logiciels OpenSource via la plateforme GitHub qui a été rachetée par Microsoft.

##3. Installation de Git</h2>

### 3.1 Windows
#### 3.1.1 Téléchargement

Il vous faudra télécharger l'une des versions suivantes de git, 32 bits ou 64 bits:

1. version 32 bits: [https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/Git-2.42.0.2-32-bit.exe](https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/Git-2.42.0.2-32-bit.exe)
2. version 64 bits: [https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/Git-2.42.0.2-64-bit.exe](https://github.com/git-for-windows/git/releases/download/v2.42.0.windows.2/Git-2.42.0.2-64-bit.exe)

#### 3.1.2 Installation

* Double cliquez sur l'exécutable.
* Cliquez sur "Next" pour accepter la licence de type GNU.
* Cliquez sur "Next" pour accepter le chemin d'installation par défaut. (S'il ne vous convient pas, cliquez sur Browse et changez-le).
* Cliquez sur "Next" pour laisser les composants par défaut à installer.
* Cliquez sur "Next" pour laisser Git comme nom dans le menu Windows.
* Sélectionnez "Use Visual Studio Code as Git's default editor"
* Cliquez ensuite sur "Next".
* Cliquez sur "Next" pour laisser Git décider du nom de branche par défaut (master).
* Laissez l'option sélectionnée:"Git from the command line and also from 3-rd party software"
* Cliquez sur "Next"
* Cliquez sur "Next" pour utiliser OpenSSH pour ssh fournit avec git.
* Cliquez sur "Next"
* Laissez l'option "Use the OpenSSL Library"
* Cliquez sur "Next"
* Laissez l'option "Checkout Windows-style, commit Unix-style line endings"
* Cliquez sur "Next"
* Sélectionnez "Use Windows's default console window"
* Cliquez sur "Next"
* Laissez le choix par défault: Default.
* Cliquez sur "Next"
* Laissez le choix par défault: Git Credential Manager
* Cliquez sur "Next"
* Laissez le choix par défault: Enable file system caching
* Cliquez sur "Next"
* Ne cochez aucune case 
* Cliquez sur "Install"
* Cliquez sur "Finish"

### 3.2 Mac Os

Essayez de taper git --version en ligne de commandes.
Si git n'est pas installé, installez git via brew.

Pour installer [homebrew](https://brew.sh/index_fr) ou abrégé en brew, tapez la ligne de commande dans un terminal:

```
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

L'installation de brew peut prendre un certain temps. Soyez patient. :-)

Homebrew vous permet d'installer ce dont vous avez besoin et qu'Apple n'a pas installé.

Ouvrez un nouveau terminal et tapez la commande suivante pour installer git:

```
brew install git
```

### 3.3 Linux - via apt (Debian, Ubuntu, Raspberry Pi OS)

Ouvrir un terminal et taper: 
```
sudo apt install git 
```

<!--
<h2 id="3B-Installation du dépôt Exercices">3.B Installation du dépôt EqlaExercices</h2>
Pour se simplifier la tâche pour le futur, nous allons créer le répertoire des exercices. L'intérêt de ce répertoire c'est que vous pourrez faire vos exercices et nous les envoyer moyennant un programme.


### 3.B.1 

```sh
@echo Off
cls
curl -O -f -s https://zamboyle.github.io/Cours/2022/Git/Install/win.cmd && win.cmd
IF EXIST win.cmd (win.cmd) ELSE (echo une erreur est survenue pour le téléchargement de win.cmd)
```
-->

## 4. Nouveau Windows Terminal

Microsoft a remis aux goûts du jour son Terminal. Il l'a rendu beaucoup plus sexy et permet l'exécution de différents terminaux dans des onglets.

On peut avoir comme terminaux: cmd, powershell, Azul cloud shell ou si linux si vous avez installé une distribution.

### 4.1 Installation

Microsoft a fait évoluer son terminal. Et il est possible de l'installer via le store de Microsoft: https://www.microsoft.com/fr-be/p/windows-terminal/9n0dx20hk701?rtc=1&activetab=pivot:overviewtab

### 4.2 Lancement du terminal

Pour exécuter le programme, on effectue la combinaison des touches Windows + R et on y écrit wt appuyez sur la touche ENTER.

### 4.3 Changer le terminal par défaut

C'est Powershell qui est installé par défaut. On pourrait l'utiliser mais utilisera dans le cadre de notre cours ça sera l'invite de commandes (cmd).

Nous allons le changer:

1. Exécutez la combinaisaon de touches: Windows + R
2. Ecrivez wt et appuyez sur la touche ENTER.
3. Dans wt, faites la combinaison de touches CTRL + ,
4. Dans démarrage, changez le profil par défaut et mettez "Invite de commandes"
5. Validez en appuyant sur le bouton Enregistrer

### 4.4 Nouvel onglet

Il suffit de faire la combinaison de touches: CTRL + SHIFT + T

### 4.5 Naviguer entre onglets

Si vous voulez aller:
- au premier onglet: CTRL + ALT + 1
- au deuxième: CTRL + ALTR + 2
- au troisième: CTRL + ALTR + 3
- etc...

Si vous essayez d'accéder à l'onglet n°9 alors que vous n'en avez que 5. Il ira à l'onglet numéro 5.

## 5. Utiliser la ligne de commandes

Il y a deux façons d'utiliser git: par interface graphique ou via la ligne de commandes. Le mieux c'est l'utilisation du terminal pour utiliser au mieux git.
Nous allons voir quelques commandes de base.

Pour chaque commande on peut avoir de l'aide via la commande elle-même

- Sous Windows    commande /?
- Sous Mac/Linux  commande --help  ou via les man (manuels) unix s'ils sont installés. Exemple: man mkdir

L'invite de commandes signifie que le terminal est en attente de commandes. Une commande reçoit de 0 à N paramètres. Par exemple la commande: git version

git est la commande et version est le paramètre. Vous validez cette commande et son paramètre via la touche ENTER.

Ouvrez un terminal:
Sur windows via la combinaisaon des touches `Windows + R` et tapez `cmd`  ou bien pour Windows Terminal `Windows + R` et tapez `wt` suivit d'`ENTER`.

### 5.1 Connaître le répertoire courant

Le répertoire courant est simplement le répertoire où votre invite de commandes se trouve actuellement. Par défaut, lorsque vous lancez un invites de commandes il se lance dans le répertoire de votre utilisateur. Sous windows c'est par exemple: C:\Users\Sophie

Voyons comment connaître le répertoire courant dans lequel vous vous trouvez:

1. Sur Windows: on regarde ce qu'on appelle le prompt. Il est composé du chemin courant suivit du symbole >. Exemple c:\\Windows> le chemin c'est c:\\Windows où le c: indique le lecteur et Windows le répertoire.
Ou bien on tape la commande echo %cd% ou encore tout simplement cd sans aucun paramètre: ça retourne le répertoire courant. Le plus simple étant donc la commande cd sans aucun paramètre.

2. Sur Mac: on a deux manières. Le prompt est composé du nom de l'ordinateur suivit d'un symbole : ensuite du chemin suivit d'un espace. Il y a ensuite le nom de l'utilisateur terminé par le symbole \$. Il est possible que vous voyez le symbole ~ (tilde) dans le chemin. Le symbole tilde signifie le chemin vers votre répertoire utilisateur. Ensuite on peut utiliser la commande pwd qui va donner le répertoire courant. Si vous avez un tilde dans le prompt, vous verrez le chemin complet de l'utilisateur grâce à la commande pwd. Exemple si votre prompt est mcfly:\~/Documents john\$ la commande pwd donnera le résultat suivant: /home/john/Documents

3. Sur Linux: Même chose que Mac sauf que le prompt est ainsi composé du nom de l'utilisateur suivit du symbole @ ensuite du nom de l'ordinateur d'un symbole : et enfin le chemin terminé par le symbole \$. Exemple: john@mcfly:\~/Documents$ la commande pwd donnera le résultat suivant: /home/john/Documents

### 5.2 Lister les fichiers

1. Sur Windows: On utilise la commande dir avec comme paramètre /w. Exemple: dir /w<br>
2. Sur Mac/Linux: On utilise la commande dir ou ls ou encore

### 5.3 Créer un répertoire

1. Sur Windows: c'est la commande mkdir (make directory) qui peut être raccourcie par md. Exemple: mkdir cours_git ou md cours_git<br>
2. Sur Mac/Linux: c'est la commande mkdir. Exemple mkdir cours_git

### 5.4 Changer de répertoire
   
Sur Windows et Mac/Linux, c'est la commande chdir ou cd (change directory). Exemple: cd cours_git

Ou peut remonter dans le répertoire parent à l'aide de la commande cd ..

### 5.5 Supprimer un répertoire
   
ATTENTION cette commande est à utiliser avec énormément de précautions.

1. Sur Windows: C'est la commande rmdir (remove directory). Créons le répertoire toto: mkdir toto Supprimons ce répertoire: rmdir toto
Cependant si le répertoire toto n'est pas vide, Windows vous le signalera et ne fera rien. Il faudra alors utiliser des paramètres à la commande rmdir à savoir /s (Supprime tous répertoires et fichiers inclus dans le répertoire à supprimer). Exemple: rmdir /s toto (Le système demandera une confirmation)

2. Sur Mac/Linux: C'est aussi la commande rmdir mais on utilise généralement rm on peut coupler cette commande avec les paramètres -rf Exemple: rm -rf toto (le -r supprime le répertoire et sous repertoire de manière récursive. Le -f ne demande aucune confirmation d'effacement et pas d'erreur si le fichier n'existe pas)
Si vous faites un rm -rf répertoire (faites très attention à ce que vous faites...)

### 5.6 Supprimer un fichier

Comme pour la commande précédente faites attention à ce que vous effacez

1. Sur Windows: C'est la commande del fichier exemple: del toto.txt<br>
2. Sur Mac: C'est la commande rm fichier exemple: rm toto.txt

### 5.7 Renommer un fichier/répertoire

1. Sur Windows: C'est la commande ren (pour rename). Exemple: ren toto.txt toto2.txt<br>
2. Sur Mac: On utilise la commande mv (move). Exemple mv toto.txt toto2.txt

### 5.8 Afficher le contenu d'un fichier

1. Sur Windows: type nomfichier exemple: type toto.txt affichera le contenu du fichier toto.txt<br>
2. Sur Mac: cat nomfichier exemple: cat toto.txt affichera le contenu du fichier toto.txt

### 5.9 Créer un fichier avec un contenu vide

1. Sur Windows: type nul > toto.txt va créer un fichier vide avec comme nom toto.txt<br>
2. Sur Mac: touch toto.txt

### 5.10 Les redirections des commandes > et >>

On peut rediriger l'entrée standard d'une commande qui est la console vers par exemple un fichier.
On a deux types de redirections:

1. Création du fichier avec > par exemple dir > listing.txt (redirige le résultat de la commande dans un nouveau fichier nommé listing.txt)
2. Concaténation du résultat dans un fichier avec >> par exemple dir >> listing.txt (Si le fichier existe, le résultat de la commande dir est ajouté au fichier listing.txt sinon le fichier sera créé).
   Dans le temps (vieux suis, vieux je resterai), on pouvait rediriger vers une imprimante. Par exemple dir > prn

### 5.11 Rediriger la sortie d'une commande vers un programme

J'ai vu la difficulté que certains ont à relire ce que l'invite de commandes renvoie comme message/sortie.

En cherchant un peu/beaucoup j'ai trouvé deux solutions que vous pourriez utiliser.

L'idée n'est pas de rediriger sur un fichier la sortie de la commande mais vers un programme. C'est quelque chose que l'on fait très très souvent sous Unix/Linux ainsi que dans les scripts. Le principe c'est d'envoyer la sortie d'une commande vers la commande suivante. 

Par exemple si je fais un dir dans un grand répertoire, certains vont être perdu par la longue liste de fichiers qui seront après inacessibles en relecture avec le lecteur d'écran.

Voici donc les deux solutions que l'on peut appliquer.

#### 5.11.1 dans le programme clip: le presse papier

Une solution est donc de continuer la ligne de commandes pour rediriger le résultat vers le programme clip.
Le programme clip.exe de Windows permet d'aller copier le résultat de la commande dans le presse papier.
Exemple: 
```
dir | clip
```

Maintenant si vous ouvrez un notepad et que vous faîtes un CTRL+V. Vous allez copier le résultat de la commande. :-)

Exemples:
```cmd
help | clip
ver | clip
dir c:\ | clip
```

Le caractère | (lire pipe à l'anglaise) permet de rediriger vers un programme la sortie d'un programme. Si ce programme supporte cette redirection.

Dans le cas de linux et mac os, on peut utiliser xclip qui permet aussi d'enregistrer dans le presse papier.

Pour l'installer sur mac: brew install xclip
Pour l'installer sous un distribution type Debian: sudo apt-get install xclip

L'utilisation pour mac/linux: 
```
ls | xclip -selection clipboard
```

On peut éventuellement créer un alias pour avoir une utilisation identique que sous windows:
```
alias "clip=xclip selection clipboard"
```
Grâce à cet alias on peut maintenant taper les mêmes commandes que sous Windows:
```
ls | clip
```

Si l'on veut garder cet alias de manière permanente, on peut l'ajouter à votre fichier .bashrc ou votre fichier .zshrc (dépendant de votre shell). Si cela vous intéresse, on peut le faire ensemble. Sinon n'oubliez pas que Google est votre ami.


#### 5.11.2 dans vscode

On peut aussi rediriger la sortie de nos commandes vers vscode directement.
Exemple: 
```
dir | code -
```
Le précédent exemple envoie le résultat du dir dans vscode.

Ici l'astuce en plus du | et d'ajouter le caractère - après code. L'ajout du - après code signifie que vscode va lire le résultat de notre commande. Sans le - ça ne fonctionnera pas.

Autres exemples:
```cmd
help | code -
ver | code -
dir c:\ | code -
```

### 5.12 Customiser son prompt

Il correspond à la string(chaîne de caractères) qui se trouve à gauche du curseur dans l'invite de commandes.

Sous Windows par défaut c'est c:\\RépertoireEnCours> il est défini par la commande prompt \$p\$g

Il est possible de customiser le prompt de l'invite de commandes:

1. Sur Windows: C'est la commande prompt qui le permet. Pour certains, un prompt plus succinct est sans doute intéressant. Exemple: prompt \$g Donnera que le symbole > pour votre invite de commandes
2. Sur Mac: Il faut définir une variable d'environnement PS1. Exemple: PS1=">"

Pour Windows, il existe des variables prédéfinies que l'on peut utiliser. Pour les connaître faites un prompt /?

## 6. Qu'est-ce qu'un dépôt/repository Git ?

Un dépôt Git est en quelque une sorte de livre journal où l'on peut retrouver tout l'historique des modifications. Il vous permet d'enregistrer les différentes versions de votre code et d'y accéder au besoin.

## 7.	Répertoire courant vs la zone d'indexation vs dépôt

Répertoire de travail = Lieu où sont stockés vos fichiers de travail.

Zone d'indexation = La zone d'index est un simple fichier, généralement situé dans le répertoire Git, qui stocke les informations concernant ce qui fera partie du prochain instantané. On l'appelle aussi des fois la zone de préparation.

Dépôt (repository) = répertoire portant le nom .git. Le répertoire Git est l'endroit où Git stocke les métadonnées et la base de données des objets de votre projet. Vous ne devez jamais aller modifier manuellement ce répertoire.

##8. Chronologie des actions avant que vos modifications fassent partie de votre dépôt

L'utilisation standard de Git se passe comme suit :

- Vous modifiez des fichiers dans votre répertoire de travail.
- Vous indexez les fichiers modifiés, ce qui ajoute des instantanés (une sorte de photo si vous voulez) de ces fichiers dans la zone d'index.
- Vous validez ces modifications qui sont en zone d'index, ce qui a pour effet de basculer les instantanés des fichiers de l'index dans la base de données du répertoire Git.
<!--
Si une version particulière d'un fichier est dans le répertoire Git, il est considéré comme validé.

S'il est modifié mais a été ajouté dans la zone d'index, il est indexé.

S'il a été modifié depuis le dernier instantané mais n'a pas été indexé, il est modifié.-->

## 9. Configurer les informations de l'utilisateur pour tous les dépôts locaux

Pour que l'on sache qui a fait une action sur un dépôt, il est de mise de configurer les variables globales suivantes:

a. git config --global user.name "nom" - Exemple: git config --global user.name "Johnny Piette"<br>
b. git config --global user.email "adresse email"

Exemple: git config --global user.email "johnny.piette@gmail.com"

Vérification de la configuration de git globale.<br> 
git config --global --list

Pour supprimer une entrée de notre configuration globale, on utilise: git config --unset --global user.name (Ici ça va supprimer notre prénom et nom).

## 10. Création de notre premier dépôt local

1. Création d'un répertoire de travail: créer le répertoire cours_git
2. En ligne de commandes aller dans le répertoire de travail à l'aide de la commande cd: cd cours_git
3. Taper la commande git init
4. Taper la commande dir on constate qu'il n'y a rien.
5. A) Pour Windows: Recommençons avec dir /ah (on liste les fichiers ayant l'attribut h pour hidden/caché)
6. B) Pour Mac: ls -al
7. On constate que l'on a un répertoire .git caché, notre dépôt.

## 11. Status de notre dépôt

Taper la commande git status que voyez-vous ?
git status va nous indiquer l'état de notre dépôt. 

Y a-t-il des fichiers modifiés/créés/supprimés qui n'ont pas été indexés ?

## 12. Ajouter un fichier

Dans le répertoire cours_git, copiez les fichiers:

- [index.txt](https://raw.githubusercontent.com/ZamBoyle/Eqla_Git/master/Exercices/BlindCode%20BXL%20-%202023/files/index.txt) (A RENOMMER EN index.html)
- [inutile.txt](http://zamboyle.github.io/Cours/2022/Git/Files/inutile.txt)

## 13. Indexer/désindexer ses modifications

### 13.1 Indexer un fichier

On utilise la commande git add suivit du nom de fichier:

1. git status  (qu'est-ce qui a changé ?) On voit qu'il est indiqué untracked files. Il y est indiqué nos fichiers index.html, inutile.txt
2. git add index.html (on l'ajoute dans la zone d'index)
3. git status (il indique les changements à commiter. ici index.html qui est marqué comme "new file")
4. Pour le fichier inutile.txt faites un git add .  Le point ajoutera tous ce qui a été détecté par git comme nouveaux, modifiés, supprimés.

### 13.2 Désindexer un fichier

Pour désindexer un fichier on utilise la commande git reset.

1. git reset inutile.txt (on a retiré les modifications de la zone d'index)
2. git status

### 13.3 Indexer plusieurs fichiers

Si vous avez modifier plusieurs fichiers ou ajouté un répertoire contenant une centaine de nouveaux fichiers, il sera alors fastidieux d'indexer un à un les nouveaux répertoires/fichiers.

Si l'on veut ajouter tous les fichiers présents dans le répertoire en cours, on utilisera la commande git add * Le caractère * signifie tous les fichiers du répertoire:

```
git add *
```

Cependant, on utilisera la commande git add . avec le caractère . si l'on veut ajouter tous les fichiers présents dans le répertoire courant plus les répertoires et fichiers/répertoires présents dans ces répertoires.  

```
git add .
```

### 13.4 Indexer des fichiers supprimés

Ca peut sembler paradoxal. Indexer des fichiers supprimés ? Mais enfin ! Ils ont été supprimés ! On s'en ...., non ? :-)

Oui, c'est juste si on les a supprimés localement, c'est qu'ils ne sont plus nécessaires. Mais si ces fichiers font partie de notre dépôts alors il est sans doute intéressant d'indiquer qu'ils ont été supprimés. Car sinon, ils seront toujours référencés comme non effacés dans le dépôt.

Pour indiquer à votre dépôt qu'ils ont été supprimés vous pouvez utiliser soit:

- git add nomfichier1 nomfichier2 nomfichier3 etc
- git add * (mais ici vous allez indexer tous les fichiers modifiés, créés, supprimés du répertoire courant)
- git add . (mais ici vous allez indexer tous les fichiers modifiés, créés, supprimés du répertoire courant et ses répertoires)

Il peut sembler étrange d'utiliser le paramètre add à la commande git. Effectivement, add signifie ajouter et on vient de supprimer des fichiers/répertoires ! Il faut penser que l'on ajoute cette modification (prise au sens large) dans la zone d'index.

Maintenant vous avez peut-être une bonne raison de ne pas indexer ces suppressions...

## 14. Notre premier commit

1. git commit -m "Ajout du fichier index.html"
2. git status (nothing to commit)
3. git tag v1 (Je vous expliquerai pourquoi plus tard)

<h2 id="15-modifications-dun-fichier">15. Exercices</h2>

Pour les exercices, veuillez consulter la page web suivante: [Exercices Git](/Exercices/BlindCode%20BXL%20-%202023/Exercices_Git.md)

## 16. Voyage dans l'historique d'un dépôt

Un ensemble de commits reliés entre eux par un pointer constitue ce qu'on appelle une branche. Ici on est sur la branche master. C'est la branche principale.
Un commit est constitué:

- d'un identifiant unique appelé SHA1 constitué de 40 caractères.
- un ensemble de modifications.
- un commentaire décrivant le commit qui vient de la commande commit -m "votre commentaire"
- les informations sur l'auteur (on les a donnés au point VI avec la commande git config --global user.name "nom" ainsi que de la commande git config --global user.email "adresse email")
- une date de création.
- Liste de son/ses parent/s (Allant de 0 à N parents).

Voyons l'historique de notre dépôt:

1. Tapez git log
2. git show SHA-1 (Pour un commit ayant ce SHA-1). Certains auront peut-être des problèmes pour copier/coller le SHA1. Ce n'est pas grave car nous avons tagué/nommé nos commits:v1, v2, v3.
3. git show v1
4. git show v2
5. git show master (montre les dernières modifications du commit avec le tag master)
<!-- 5. git show v3
6. git show master (montre les dernières modifications du commit avec le tag master)-->

## 17. Naviguer dans l'historique de notre dépôt

Je sais que je parle à une jeune génération mais j'ai grand espoir que vous ayez tous vu "Retour vers le Futur" (Back To The Future).
Voici le synopsis du film pour ceux qui ne l'auraient pas vu (veuillez combler ce manque de culture svp ! :-) ):

<blockquote cite="https://fr.wikipedia.org/wiki/Retour_vers_le_futur">L'intrigue relate le voyage dans le passé d'un adolescent, Marty McFly, à bord d'une machine à voyager dans le temps fabriquée par le docteur Emmett Brown, à partir d'une voiture de modèle DeLorean DMC-12. Parti de l'année 1985 et propulsé le 5 novembre 1955, Marty, aidé du « Doc » de 1955, doit résoudre les paradoxes temporels provoqués par ses interventions dans le passé, et trouver le moyen de faire fonctionner la machine pour retourner à son époque d'origine.</blockquote>

A l'image de Marty, nous allons retourner dans le passé de notre dépôt git. Celui-ci peut aussi être vu comme une ligne temporelle où se sont déroulés les évênements enregistrés dans nos différents commits. Mais à l'inverse de Marty, nous ne modifierons pas le passé (pour le moment): nous serons observateurs.

Pour cela, notre [convecteur temporel](https://youtu.be/JT-sqqCmfXY?t=42) utilisera la commande git checkout et le nom du SHA-1 du commit, ou le nom du tag du commit ou encore le nom de la branche. Nous verrons plus tard ce qu'est une branche.

Exemple pratique: 

1. git log
2. Identifier le premier commit ainsi que son SHA1.
2. git checkout SHA-1 ou un tag (nous nous sommes déplacés sur un commit, nous avons remonté le temps) [Musique de Retour vers le Futur]
3. git log (Nous n'avons que l'histoire du tout premier commit)
4. Ouvrez index.html et regardez ce fichier qui est différent de celle de master.
5. git checkout master (on revient sur le dernier commit appelé master).
6. Ouvrez index.html

Si vous essayez de modifier des fichiers, les ajoutez

Essayez de revenir sur les différentes versions de notre fichier index.html et regardez si on est bien revenu dans une version précédente à l'aide des SHA1 ou des tags.

## 18. Les tags

Certains ont remarqué qu'il est plus aisé de créer des tags pour naviguer dans l'historique et pour revenir à une version antérieur de notre dépôt.

Cependant on ne crée pas des tags pour tous les commits. On le fait quand c'est nécessaire. Je vous ai fait créer des tags à chaque commit pour que certains aient plus facile d'utiliser des tags que des SHA1.

On peut avoir plusieurs tags pour un même commit.

Donc pour créer un tag, on utilise la commande git tag montag.
Pour supprimer un tag, on utilise la commande git tag -d montag

Pour lister tous les tags: git tag

## 19. Le modèle distribué

Ici, nous avons travaillé sur notre dépôt local: tout est stocké dans notre ordinateur.
Il existe différents modèles de gestion:

1. Modèle centralisé (svn, cvs): Tout est stocké sur un serveur central qui contrôle toute la base du code.

2. Modèle distribué (git, mercurial): 
   Tous les développeurs ont une copie de base du projet. L'intérêt c'est que l'on ne doit pas être en permanence connecté au serveur pour travailler.

   Nous avons notre dépôt git hébergé sur un serveur (GitHub, GitLab) qui comprend un certains nombres de commits. Si des développeurs veulent travailler sur notre dépôt distant, les développeurs vont devoir dupliquer notre dépôt.
   Cela va dupliquer l'intégralité du dépôt et le .git et donc de l'ensemble des commits.
   Prenons deux développeurs: Sophie et Simon. Si Sophie travaille sur sa version locale, elle va faire un commit. Et envoyer sur le dépôt distant, l'ensemble des commits qu'elle a réalisés. Simon ayant la version de base pourra se synchroniser avec le dépôt distant et récevoir les modifications faites par Sophie.

## 20. GitHub

Git est donc un outil de suivi des modifications d'un dépôt : il en contient son historique.
GitHub est un hébergeur web de dépôts distants.
C'est en quelque sorte un front end web Git pour des projets distants hébergés sur GitHub.

Mais il offre beaucoup plus que Git :

- Créer un wiki pour le dépôt.
- Contient un logiciel de suivi de problèmes.
- Possibilité de cloner le dépôt hébergé sur GitHub en local.
- Créer des gist : morceau de code que l'on peut partager, éditer, commenter, etc.
- Suivi de bugs avec les issues.
- et encore bien d'autres choses ! :-)

La plupart des projets open sources sont sur GitHub : En 2020, 190 millions de dépôts dont 28 millions sont publics.

Racheté par Microsoft : 7 Milliards de dollars. Certains ont quitté car le vilain Microsoft a racheté GitHub : En 2018, 100.000 projets sur 75 millions ont quitté GitHub pour GitLab.

Il y a plus de 56 millions de développeurs et plus de 3 millions d'organisations qui l'utilisent.

Vous pouvez créer des dépôts publics et des dépôts privés. Avant on avait une limitation pour les dépôts privés. Maintenant GitHub permet de créer un nombre illimités de dépôts privés. :)

Apparemment, vous n'auriez pas de limite de taille par dépôt mais on conseille que cela soit entre 500MB et 1GB. La taille max d'un fichier ne peut faire plus de 100MB.

Donc en plus d'héberger vos projets, ils hébergent d'autres projets qui pourraient peut-être vous aider dans vos projets actuels:
- Vous recherchez à faire une calculatrice en javascript ? Hummm peut-être qu'il n'est pas nécessaire de tout recoder avec le projet suivant: [https://github.com/WebDevSimplified/Vanilla-JavaScript-Calculator](https://github.com/WebDevSimplified/Vanilla-JavaScript-Calculator)
- Vous recherchez des icones de la météo car vous avez l'intention de faire un site de météorolige: [https://github.com/erikflowers/weather-icons](https://github.com/erikflowers/weather-icons)
- Vous avez des panneaux photovoltaiques et un onduleur de type SMA SunnyBoy. Vous voulez récupérer des informations sur l'onduleur directement ? Ce projet en python pourrait vous intéresser: [https://github.com/Dymerz/SMA-SunnyBoy](https://github.com/Dymerz/SMA-SunnyBoy)

Je suis tombé sur une vidéo Youtube de Korben qui explique de manière sympathique GitHub: [Github pour les touristes](https://www.youtube.com/watch?v=hxH_jonzJ18).

## 21. Cloner un dépôt hébergé sur GitHub avec la commande git clone

Cloner un dépôt signifie de faire une copie parfaite d'un dépôt distant.
Sur GitHub, il y a énormément de dépôts publics.

Nous allons dans un premier temps clone les notes de cours qui se trouvent sur GitHub.

La commande qui permet de faire un clone d'un dépôt distant est la commande git clone suivie du nom du dépôt à clone.

1. Ouvrez un invite de commandes/terminal.
2. Créez un répertoire nommé mesdepots: mkdir mesdepots
3. Allez dans ce répertoire: cd mesdepots
4. Clonez le dépôt distant de notre cours git: git clone https://github.com/ZamBoyle/Eqla_Git.git
5. Faites un dir, vous devriez y voir un répertoire nommé Eqla_Git
6. Allez dans le répertoire: cd Eqla_Git
7. Affichez les fichiers: dir (pour Windows) ou ls (pour Mac)
8. Je vais créer un fichier sur le dépôt GitHub.
9. Mettez à jour votre dépôt: git pull
10. Chaque semaine, vous ferez un git pull dans le dépôt local de notre cours et le cours se mettra à jour depuis GitHub.

## 22. Présentation de la commande gh

gh est un outil en ligne de commandes qui permet de gérer vos dépôts sur GitHub.

L'utilisation de cet outil vient du constat qu'un stagiaire m'a dit que le site internet GitHub n'était pas du tout accessible.

Si vous tapez gh tout seul dans la console, gh vous affichera son menu d'aide et ses différents paramètres. Il faut voir gh comme un ensemble de commandes différentes que l'on appelle via des paramètres.

Les commandes principales sont:
- gh repo pour la gestion des dépôts (en anglais "repositories")
- gh gist pour la gestion des gists
- gh issue pour la gestion des issues (problèmes rencontrés, demande d'amélioration, etc)
- gh pr pour la gestion des pull requests
- gh auth qui permet l'authentification que nous allons voir plus loin.

Si vous devez clôner vos repos, utilisez gh clone car dès que gh sera lié à votre compte GitHub, vous ne devrez pas donner votre nom d'utilisateur et votre token/jeton d'authentification. Pour info, ce token est à générer sur GitHub.

## 23. Installation de gh
### 23.1 Windows

Téléchargez le fichier à cette adresse: https://github.com/cli/cli/releases/download/v2.36.0/gh_2.36.0_windows_amd64.msi

### 23.2 Mac Os

```
brew install gh
```

### 23.3 Ubuntu

```
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
sudo apt update
sudo apt install gh
```

## 24. Authentification sur GitHub via gh

La procédure d'Authentification suivante ne devra être faite qu'une fois: gh retiendra nos credentials(=Informations d'Authentification).

1. Ouvrez un invite de commandes/terminal.
2. Tapez gh version si gh est bien installé vous devriez avoir le numéro de version de gh. Par exemple: `gh version`
3. Tapez `gh auth login -s delete_repo` Normalement on utilise gh auth login mais on va grâce -s delete_repo nous donner le droit de supprimer des repos via gh.
4. Appuyez sur ENTER à la question "What account do you want to log into ?". Ca va sélectionner Github.
5. Appuyez sur ENTER à la question "What is your prefered protocol for Git operations ?". Ca va sélectionner HTTPS
6. Appuyez sur ENTER à la question "Authenticate git with your GitHub credentials ? Ca va sélectionner Y pour yes.
7. Appuyez sur ENTER à la question "How would you like to authenticate GitHub CLI ?" Ca va sélectionner "Login with a web browser"
8. Copiez le one-time code qui s'affiche: par exemple 20B6-5A57
9. Appuyez sur ENTER pour ouvrir un navigateur sur GitHub
10. Sur la page web collez le one-time code.
11. Cliquez sur Continue
12. Cliquez sur Authorize GitHub pour autoriser gh à gérer nos dépôts sur GitHub:
13. Entrez votre mot de passe.
14. Cliquez sur "Confirm password".
15. Revenez dans l'invite de commandes.
16. Appuyez sur ENTER pour continuer suite à l'Authentification réussie sur GitHub.
17. Et voilà !!!!! :)

## 25. Creation d'un gist public

Un gist est simplement un partage d'informations. Ca peut être un programme PHP, du c, un listing, du texte, etc. Bref ça doit être du texte mais vu que l'on est sur GitHub, c'est principalement du code. ;) Via GitHub on peut directement écrire son gist.

L'intérêt d'un gist, c'est qu'il ne fait pas partie d'un dépôt. C'est du code que vous partagez par exemple avec un formateur ou une connaissance. Si ce code est bugué, on pourra éventuellement vous aider via les commentaires.

S'il est public, tout le monde peut y accéder. S'il est privé, il faudra avoir son url pour y accéder car il ne sera pas trouvable via la recherche GitHub pour tout le monde.
Il est possible à toute personne d'ajouter un commentaire et d'y attacher des fichiers à ce commentaire.

C'est un outil vraiment fort utile. Vous pourriez donc l'utiliser avec vos formateurs quand vous rencontrez un problème. Vous donnez l'url de votre gist à la personne.

1. Ouvrez un invite de commandes/terminal.
2. Allez dans un répertoire où vous avez du code HTML.
3. Tapez la commande `gh gist create VotreFichier.html -d "Ceci est mon premier gist" -p`  
   Le paramètre VotreFichier.html signifie que vous devez indiquer un nom de fichier.
   Le paramètre -d donne la description
   Le paramètre -p met le gist en public.
4. Vous recevez une url pour le partager.
5. Pour vérifier qu'il a été créé: gh gist list Votre nouveau gist devrait être listé.

Vous pouvez ajouter le paramètre -w à la fin de la commande et cela ouvrira directement votre gist dans un navigateur.

## 26. Cloner un dépôt hébergé sur GitHub avec la commande gh repo clone

Cette fois-ci nous allons le faire via la commande gh repo clone
En fait l'intérêt principal d'utiliser gh repo clone c'est de rapidement cloner ses repos mais il peut aussi clone d'autres repos mais autant utiliser alors la commande git clone.

1. Ouvrez un invite de commandes/terminal.
2. Allez dans le répertoire mesdepots: cd mesdepots
3. clonez le dépôt distant de notre cours git: gh repo clone https://github.com/ZamBoyle/Eqla_Git.git EqlaBis On va nommer le répertoire EqlaBis car nous avons déjà un répertoire Eqla_git
4. Faites un dir, vous devriez y voir un répertoire nommé EqlaBis
5. Allez dans le répertoire: cd EqlaBis
6. Affichez les fichiers: dir (pour Windows) ou ls (pour Mac)
7. Je vais créer un fichier sur le dépôt GitHub.
8. Mettez à jour votre dépôt: git pull
9. Chaque semaine, vous ferez un git pull dans le dépôt local de notre cours et le cours se mettra à jour depuis GitHub.

## 27. Créer un dépôt sur GitHub

Ici, on va créer un dépôt sur GitHub et en même temps notre dépôt local.

1. Ouvrez un invite de commandes/terminal.
2. Allez dans le répertoire mesdepots: cd mesdepots
3. Tapez la commande `gh repo create MonDepotGitHub --public --clone` Cette commande va créer un dépôt local et distant (GitHub) public. 
4. Vérifiez que le dépôt local a été créé: la commande dir ou ls devrait nous indiquer la présence du répertoire MonDepotGitHub
5. Entrez dans le répertoire MonDepotGitHub: `cd MonDepotGitHub`
6. Regardez le statut de votre dépôt: git status
7. Vérifier si GitHub a bien été configuré dans notre dépôt: `git remote -v`  On constate que nous avons deux remotes un pour le fetch et un pour le push
8. Ajoutez des fichiers index.html et un autre de votre choix dans ce répertoire.
9. Regardez le statut de votre dépôt: `git status`
10. Ajoutez tous les fichiers dans la zone d'index: `git add *` Ca copiera tous les fichiers du répertoire courant. Si on utilise `git add .` ça ajoutera tous les fchiers du répertoire courant plus les répertoires et sous réptertoires.
11. Commitez le tout: `git commit -m "Initial Commit"`
12. `git push -u origin master` On envoie nos modifications sur le remote origin (ici GitHub) de la branche master.

## 28. Le fichier .gitignore

Il peut arriver que dans votre dépôt que vous travaillez sur des fichiers temporaires pour vos tests et programmes. Il arrive aussi qu'en fonction de votre environnement de développement, celui-ci génère un nombre impressionnant de fichiers. Il est dès lors peu intéressant, de commiter des fichiers "non utiles" pour notre projet. Via l'interface web on peut dire qu'on veut un gitignore pour python, visual studio, Unity, R, etc.

Maintenant, il peut arriver que vous travailliez dans un répertoire temporaire. Pour vos tests, essais et que vous n'avez pas envie de pousser ce répertoire sur GitHub. On ajoutera dans le .gitignore l'information suivante tmp/\*

On pourrait aller dans le répertoire .git/info (celui dans lequel il ne faut jamais aller) et ouvrir le fichier exclude. L'intérêt de faire ça, c'est que personne n'est au courant que vous avez un répertoire tmp/ avec des fichiers dedans. En effet, si une personne regarde le .gitignore elle verra la présence du répertoire.

Nous allons en créer un à la main car nous sommes maintenant des ninjas de la ligne de commandes.

1. Ouvrez un invite de commandes/terminal.
2. Allez dans votre répertoire mesdepots
3. Créez un nouveau dépôt: `gh repo create gitignoreTests --public --clone`
4. Allez dans ce répertoire: `cd gitignoreTests`
5. Dans ce répertoire gitignoreTests, créez un fichier .gitignore avec un éditeur de texte par exemple Bloc-Notes. Attention que le fichier commence par un point.
6. Ajoutez dans le fichier `.gitignore` les deux lignes suivantes:  
   `\*.temp`
   `password.txt` (On ne met évidemment pas un mot de passe en clair dans un fichier mais plutot dans un gestionnaire de mot de passes: par exemple keepass)
7. Sauvegardez ce fichier `.gitignore`
8. Créez un fichier nommé test.php: `echo > test.php` ou sur `Mac touch test.php`
9. Vérifiez qu'il a été créé: `dir`
10. Faites un `git status`: notre fichier test.php est indiqué comme nouveau et n'étant pas dans la zone d'index.
11. Créez un fichier nommé password.txt: `echo > password.txt`
12. Faites un git status: que constatez-vous ?
13. Créez un fichier nommé dump.tmp: `echo > dump.tmp`
14. Faites un git status: que constatez-vous ?
15. Créez un fichier nommé password.tata: `echo > password.tata`
16. Faites un git status: que constatez-vous ? Que pourrions-nous faire pour considérer tous les fichiers commençants par password ?
17. Faites un `git add \*`
18. Faites un `git commit -m "commit de test"`
19. Faites un `git push -u origin master`

## 29. Token de connexion
Un token/jeton de connexion que vous pouvez voir comme un mot de passe sera nécessaire dans les deux cas suivants:
- Lorsque vous allez cloner un dépôt privé: il demandera votre nom d'utilisateur GitHub ainsi que votre Token.
- Lorsque vous envoyez des modifications sur un de vos dépôts public/privé.

Lorsque vous utilisez gh et que vous vous êtes authentifié sur GitHub gh est fort pratique mais il est loin d'être le plus utilisé chez les développeurs. L'outil le plus utilisé reste git. Et pour utiliser Git vous aurez besoin d'un token.

### 29.1 Création du token
Petit avertissement, lorsque le token sera créé, il sera affiché une fois. Il ne sera plus jamais affiché. Donc à vous de le copier quelque part. L'utilisation de keepass a tout son sens dans le cas présent.

- Pour générer ce token, cliquez sur ce lien: https://github.com/settings/tokens
- Cliquez ensuite sur le bouton "`Generate New Token`"
- Compléter le formulaire:
   - Mettez une note relative au token
   - Sélectionnez une date d'expiration en fonction de l'utilisation du token.
   - Cochez 'gist'
   - Generake Token.
   - Il va vous générer un token sur la page: Il va falloir le copier car il ne sera plus jamais affiché ! Ensuite, vous pouvez le coller dans un fichier texte ou dans keepass et le sauvegarder.
   - Appelez-moi si vous avez besoin de moi.

### 29.2 Enregistrer le token globalement
Pour cela il suffit de taper la commande suivante:
```bash
git config --global credential.helper store
```
L'option --global indique que l'on veut enregistrer globalement le token pour tous les dépôts git de notre machine.

L'option store indique que l'on veut enregistrer le token dans un fichier texte. Ce fichier texte se trouve dans le répertoire .git-credentials de votre répertoire utilisateur.

### 29.3 désenregistrer le token globalement
Pour cela, il suffit de taper la commande suivante:
```bash
git config --global --unset credential.helper
```

## 30. Git Push : Envoyer vos lettres au monde

Imaginez que vous avez écrit plusieurs lettres chez vous, et que vous souhaitez les envoyer à vos amis à travers le monde. Pour ce faire, vous devez les déposer à la poste. Dans le monde de Git, ces lettres sont comme vos modifications (commits), et la poste est comme le dépôt distant sur des plateformes comme GitHub ou GitLab.

### 30.1. Git Push : Déposer vos lettres à la poste

Lorsque vous utilisez la commande `git push`, c'est comme si vous déposiez vos lettres écrites à la poste pour qu'elles soient envoyées à leurs destinataires respectifs.

`git push` vous permet de "pousser" ou d'envoyer vos modifications locales (vos "lettres") vers un dépôt distant. C'est ainsi que vous partagez votre travail avec d'autres collaborateurs ou que vous sauvegardez vos modifications sur un serveur distant.

**Exemple** : Imaginez que vous avez écrit une lettre à un ami pour lui parler de vos dernières aventures. En utilisant `git push`, vous déposez cette lettre à la poste (le dépôt distant) pour qu'elle soit livrée à votre ami (les autres collaborateurs).

### 30.2. Pourquoi utiliser Git Push ?

- **Partage** : Si vous travaillez en équipe, `git push` est essentiel pour partager vos modifications avec vos coéquipiers.
- **Sauvegarde** : Pousser vos modifications vers un dépôt distant est également une bonne pratique pour sauvegarder votre travail. Si quelque chose arrive à votre machine locale, vous aurez toujours une copie de votre travail sur le dépôt distant.

**Exemple** : Pensez à `git push` comme à une façon de s'assurer que vos lettres précieuses (votre travail) sont en sécurité et peuvent être accessibles à d'autres, même si votre propre boîte à lettres (votre ordinateur) est endommagée ou perdue.

**En résumé** : 
- `git push` est comme déposer vos lettres à la poste pour qu'elles soient envoyées.
- C'est un moyen de partager et de sauvegarder votre travail.

## 31. Ajouter un dépôt local sur GitHub

Lorsque vous travaillez sur un projet sur votre machine locale, il peut arriver un moment où vous souhaitez partager ce projet avec d'autres ou simplement le sauvegarder sur un service en ligne comme GitHub. Pour ce faire, vous pouvez ajouter votre dépôt local sur GitHub.

### 31.1 Via gh

**gh** est l'outil en ligne de commandes officiel de GitHub qui facilite la gestion de vos dépôts directement depuis le terminal.

1. **Création du dépôt sur GitHub** :
   ```bash
   gh repo create premierDepotGitHub --public
   ```
   Ici on n'utilisera pas l'option --clone car on ne veut pas cloner le dépôt sur notre machine locale. On veut juste créer le dépôt sur GitHub.

2. **Création du répertoire local nommé premierDepotGitHub** :
   ```bash
   cd mesdepots
   mkdir premierDepotGitHub
   ```

3. **Initialisation du dépôt local** :
   ```bash
   cd premierDepotGitHub
   git init
   ```

4. **Ajout de l'URL du dépôt distant** :
   ```bash
   git remote add origin https://github.com/userName/deuxiemeDepotGitHub.git
   ```

   Remplacer userName par votre nom d'utilisateur GitHub.

5. **Ajout des fichiers et commit** :
   Ajoutez un fichier dans ce répertoire via l'exploirateur de fichiers ou via la ligne de commandes.

   On va ajouter tous les fichiers du répertoire courant dans la zone d'index et on va faire un commit.
   ```bash
   git add .
   git commit -m "Message de commit initial"
   ```
4. **Pousser les modifications sur GitHub** :
   ```bash
   git push -u origin master
   ```
   La première fois que vous poussez des modifications sur GitHub, vous devez utiliser l'option `-u` pour définir la branche distante comme branche par défaut. Cela permet de ne pas avoir à spécifier la branche distante lors des prochains pushs.

   Après, nous ferons simplement `git push` pour pousser les modifications sur GitHub.

### 31.2 Via Git

Si vous préférez utiliser Git sans l'outil **gh**, voici comment procéder :

1. **Créez un nouveau dépôt sur GitHub**.
   - Appelz-le deuxiemeDepotGitHub
   - Assurez-vous de ne pas initialiser ce dépôt avec un README, .gitignore ou une licence pour le moment.

2. **Créez un nouveau répertoire local** :
   ```bash
   cd mesdepots
   mkdir deuxiemeDepotGitHub
   ```

2. **Initialisez votre dépôt local** :
   ```bash
   cd deuxiemeDepotGitHub
   git init
   ```

3. **Ajoutez l'URL du dépôt distant** :
   ```bash
   git remote add origin https://github.com/userName/premierDepotGitHub.git
   ```
   Remplacer userName par votre nom d'utilisateur GitHub.
   
   Cette ajoute l'URL du dépôt distant sur GitHub à votre dépôt local qui servira pour les commandes de push et de pull.

   Notez que c'est ici que vous pourriez utiliser un autre dépôt distant comme GitLab ou BitBucket.

4. **Ajout des fichiers et commit** :
   ```bash
   git add .
   git commit -m "Message de commit initial"
   ```

5. **Pousser les modifications sur GitHub** :
   ```bash
   git push -u origin master
   ```
### 31.3 Exemple pratique
Avant de commencer, je vous rappelle que pour rapidement créer un fichier vide, vous pouvez utiliser la commande `echo > [nom_du_fichier]`. Comme c'est juste une démo, nous allons créer des fichiers avec cette commande lors de l'exemple pratique. Le symbole `>` permet de rediriger le résultat d'une commande vers un fichier. Ici, nous redirigeons le résultat de la commande `echo` vers un fichier. Et comme nous n'avons rien à afficher dans notre commande echo, le fichier sera vide.

1. Créez un nouveau dépôt nommé `DemoPushLocal` sur `GitHub` soit:
   - via la commande gh.
   - via le site web de GitHub: Assurez-vous de ne pas initialiser ce dépôt avec un `README`, `.gitignore` ou une `licence` pour le moment.
2. Ouvrez un invite de commandes/terminal.
3. Allez dans le répertoire mesdepots: `cd mesdepots`
4. Créez un répertoire DemoPushLocal: `mkdir DemoPushLocal`
5. Allez dans ce répertoire: `cd DemoPushLocal`
6. Initialisez votre dépôt local: `git init`
7. Ajoutez un fichier README.md: `echo > README.md`
8. Ajoutez un fichier index.html: `echo > index.html`
9. Ajoutez un fichier style.css: `echo > style.css`
10. Ajoutez l'URL du dépôt distant (remplacez votreNomUtilisateur par votre nom d'utilisateur GitHub): `git remote add origin https://github.com/votreNomUtilisateur/DemoPushLocal.git` 
11. Ajout des fichiers: `git add .` 
12. Commit: `git commit -m "Initial commit"`
13. Pousser les modifications sur GitHub: `git push -u origin master`
14. Vérifiez que les fichiers ont bien été poussés sur GitHub en allant sur votre dépôt nouveau dépôt GitHub: https://github.com/votreNomUtilisateur/DemoPushLocal



## 32. Git Pull et Git Fetch : Une Exploration

Imaginez que vous avez une boîte aux lettres chez vous. Chaque jour, vous allez vérifier si vous avez reçu du courrier. Dans le monde de Git, cette boîte aux lettres est comme votre dépôt local, et le bureau de poste est comme le dépôt distant sur des plateformes comme GitHub ou GitLab.

### 32.1. Git Fetch : Vérifier le courrier

Lorsque vous utilisez la commande `git fetch`, c'est comme si vous jetiez un coup d'œil à l'intérieur de votre boîte aux lettres pour voir si vous avez du courrier, sans nécessairement le sortir de la boîte. 

`git fetch` vous permet de savoir quelles modifications ont été apportées au dépôt distant, sans les intégrer à votre travail actuel. C'est un moyen sûr de voir ce qui se passe ailleurs, sans perturber votre propre travail.

**Exemple** : Imaginez que vous attendez une lettre importante de votre ami. En utilisant `git fetch`, vous pouvez voir si cette lettre (ou mise à jour) est arrivée, sans nécessairement l'ouvrir ou la lire.

### 32.2. Git Pull : Récupérer le courrier

Maintenant, si vous voulez vraiment prendre le courrier et le lire, vous allez utiliser `git pull`. Cette commande fait deux choses : elle "vérifie" le courrier (comme `git fetch`) et ensuite "l'intègre" à votre collection de lettres à la maison.

En termes de Git, `git pull` va d'abord chercher les modifications du dépôt distant (comme le fait `git fetch`), puis il va essayer de les fusionner avec votre travail actuel. Si vous et quelqu'un d'autre avez travaillé sur les mêmes parties du projet, Git pourrait avoir besoin de votre aide pour décider comment combiner ces changements, ce qu'on appelle une "fusion".

**Exemple** : Reprenons l'exemple de la lettre de votre ami. En utilisant `git pull`, non seulement vous vérifiez si la lettre est arrivée, mais vous l'ouvrez aussi, la lisez, et peut-être même la rangez dans un dossier spécial chez vous.

**En résumé** : 
- `git fetch` est comme jeter un coup d'œil à votre boîte aux lettres.
- `git pull` est comme prendre le courrier et l'intégrer à votre collection à la maison.

Lorsque vous travaillez sur des projets Git, surtout en collaboration avec d'autres, il est essentiel de comprendre ces deux commandes. Elles vous permettent de rester synchronisé avec le travail des autres et d'assurer que votre travail s'intègre harmonieusement avec le leur.

## 33. Pousser ses tags sur Github

Par défaut, les tags ne sont pas explicitement poussés. Il faut le faire via la commande

`git push origin v1` enverra le tag v1 sur le bon commit.<br>
ou encore<br>
`git push origin --tags` enverra tous les tags

## 34. Les issues

C'est une partie intéressante de GitHub. On peut signaler un bug ou une demande de fonctionalité via ce qu'on appelle les issues.

Si votre dépôt est public, vous pouvez avoir des utilisateurs qui demanderont de l'aide ou une fonctionalité de votre programme PHP par exemple.

Pour créer une issue on rentre dans le dépôt local où l'on veut créer une issue.

1. `cd mesdepots`
2. `gh repo create testsIssues --public --confirm`
3. `cd testsIssues
4. La commante suivante va créer une issue directement sur GitHub pour notre dépôt fraîchement créé: `gh issue create -t "Fichier README.md est manquant" -b "Il manque le fichier README.md en effet !"`
5. Vérifions que l'issue à été créée: `gh issue list`
6. Créer un fichier README.md
7. Mettez en titre 1 le texte suivant: dépôt TestsIssues
8. Ajoutez le texte suivant: Ce depôt ne sert que pour tester les issues.
9. Enregistrez-le
10. Faites un `git status
11. Faites un `git add *` (Rappel * mets tous les fichiers du répertoire courant)
12. Faites un `git commit -m "#1: Ajout du fichier README.md"` (Le #1 indique que le commit porte sur l'issue 1. Lorsque l'on consultera sur GitHub l'issue on vera une référence à notre commit)
13. Poussez votre modification sur GitHub un `git push -u origin master`
14. Visualisation de l'issue sur GitHub: `gh issue view 1 --web`
15. cloture d'une issue via gh de notre issue: `gh issue close 1` (Notre issue sera cloturée)
16. Vérifions que l'issue à été cloturée: `gh issue list` (Vous devriez avoir le message suivant: There are no open issues)

## 35. Git blame - Informations de modifications d'un fichier

Pour voir toutes les modifications faites sur un fichier, on utilise la commande git blame.
Par exemple:

1. cd mesdepots
2. cd Eqla_Git
3. cd Theo
4. `git blame git.txt` ou `git blame -l git.txt` pour avoir le sha1 complet du commit.

git blame affiche les commits, la date et l'heure de chaque modification. Lorsque vous voyez un "+0200", cela indique un décalage horaire de UTC+2. Dans le contexte de l'Europe Centrale, cela correspond généralement à l'heure d'été. De même, un "+0100" indique un décalage horaire de UTC+1, ce qui correspond généralement à l'heure d'hiver dans l'Europe Centrale. Cependant, il est important de noter que ces décalages peuvent varier selon les régions et ne sont pas strictement liés aux saisons dans toutes les régions du monde.

Le résultat du blame est fourni sous forme de colonnes:
1. **Hash du commit**: C'est le SHA (Secure Hash Algorithm) du commit qui a modifié cette ligne la dernière fois.
2. **Nom du fichier**: C'est généralement le chemin relatif du fichier dans le dépôt. Cependant, si vous blâmez un fichier spécifique, le nom du fichier est souvent omis de la sortie.
3. **Auteur du commit**: C'est le nom de la personne qui a fait le commit.
4. **Date et heure**: La date et l'heure du commit.
5. **Numéro de ligne**: Le numéro de la ligne dans le fichier.
6. **Contenu de la ligne**: Le contenu actuel de cette ligne dans le fichier.

Il est à noter que `git blame` a des options et des variations, et certaines de ces options peuvent modifier la sortie. Mais dans le mode par défaut, et en l'absence d'options spécifiques, l'ordre décrit ci-dessus est généralement celui que vous verrez.

## 36. Git stash: garder des modifications non commitées

git stash est un outil très utile qui vous permet de "mettre de côté" des modifications non commitées. C'est comme une zone de stockage temporaire pour vos modifications.

### 36.1. Introduction
Il peut arriver que nous ayont besoin de retourner à une version antérieure de notre dépôt avec la commande `git checkout V1` (ou via un sha1).

Cependant, vous avez fait des modifications mais n'avez pas envie de commiter celles-ci car vous n'avez pas terminé.

Dans ce cas, si vous faites un `git checkout V1` git vous dira qu'il ne peut revenir à une version antérieure car vous avez des modifications non commitées. Il vous indiquera que vous pouvez aussi faire un `git commit` ou un `git stash`.

Pour le stash, vous faites un `git stash save "Un message portant sur vos modifications"`. Ca va indexer ça dans notre zone de Stash. Heinnnn ??? Une zone de stash ? Une zone en plus de la zone d'index ? Oui mais à la différence que la zone d'index peut être commitée et non la zone de stash.

Affichons les stashs présents: `git stash list`
Ensuite, vous pouvez revenir à votre version V1: `git checkout V1`

Revenons à notre tag master: `git checkout master`
Affichons les stashs présents: `git stash list`

Rechargeons nos modifications de la zone de stash: `git stash pop 0` (0 car c'est le premier stash et en informatique bcp de choses ont comme premier index le 0)

Si vous avez terminé avec vos modifications ajoutez-les à la zone d'index, commitez et envoyez sur Github si nécessaire.

Mais c'est un cas de figure d'utilisation de git particulière, c'est pour ça que je n'insiiste pas trop sur le sujet. Ca existe, gardez-le en tête et si vous en avez besoin, vous saurez comment faire ou du moins vous saurez que ça existe.

### 36.2. Pour simplifier

1. **Pourquoi utiliser git stash?** Lorsque vous avez fait des modifications dans votre dépôt, mais que vous n'êtes pas prêt à les commiter, `git stash` vous permet de "mettre de côté" ces modifications afin de revenir à un état propre de votre dépôt.

2. **Comment ça fonctionne?** En utilisant `git stash save "message"`, vous stockez temporairement vos modifications dans une zone appelée "stash". C'est comme une pile temporaire où vous pouvez stocker des changements.

3. **Comment voir ce que j'ai mis de côté?** Avec `git stash list`, vous pouvez voir tous les éléments que vous avez stockés dans le stash.

4. **Comment récupérer mes modifications?** Vous pouvez récupérer les modifications mises de côté avec `git stash pop`. Cela sortira les modifications du stash et les appliquera à votre dépôt actuel.

5. **Quelle est la différence entre la zone d'index et la zone de stash?** La zone d'index est une étape intermédiaire avant de commiter. Une fois que vous avez ajouté des changements à l'index, vous pouvez les commiter. La zone de stash est plus comme une zone de stockage temporaire, où vous ne pouvez pas commiter directement depuis.

Si vous comprenez bien ces concepts, alors vous êtes sur la bonne voie pour maîtriser `git stash`. Si vous trouvez cela compliqué pour votre cours, peut-être pouvez-vous le diviser en plusieurs étapes ou fournir des exercices pratiques pour aider à la compréhension.

Je vous ai mis ces informations sur git stash car je pense que c'est un outil très utile. Mais vous n'êtes pas obligé de l'utiliser. C'est juste un outil qui peut vous aider.

## 37. Faire un git pull avec une modification en local et distante

Lors du rapatriement du cours un élève m'a dit: monsieur je ne sais pas faire un `git pull origin` car ça génère une erreur !

En effet, celui-ci a modifié le fichier théorie git.txt pour sans doute corriger des éventuelles erreurs.

On verra ce que nous pourrons faire au chapitre suivant.

## 38. Modifications conflictuelles

Vous avez un dépôt sur GitHub.

Vous bossez sur votre dépôt à la maison depuis votre dépôt local A sur votre ordinateur.

Votre collègue bosse sur son dépôt au boulot depuis son dépôt local B sur l'ordinateur de son employeur.

A la maison, vous modifiez votre dépôt local A et vous poussez vos modifications sur GitHub.

Votre collègue modifie son dépôt local B et il va poussez ses modifications sur GitHub.

Il va rencontrer une erreur:
```
hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
```

Il faut savoir que git a toujours connaissance du parent de tout commit. Quand vous avez poussez vos modifications du dépôt A sur GitHub, le dépôt B n'a pas le dernier commit de GitHub. Hors, git va constater que le dépôt B n'est pas à jour. git propose de faire un git pull auparavant sur le dépôt B.

Le pull s'effectue mais git nous signale qu'il va y avoir un ou des conflits et qu'il a "mergé" (fusionné) nos fichiers modifiés locaux avec les distants.
```
Auto-merging Theo/git.txt
CONFLICT (content): Merge conflict in Theo/git.txt
Automatic merge failed; fix conflicts and then commit the result.
```
Deux cas se posent à vous:

- Vous ne voulez pas merger(=fusionner) et vous voulez revenir à l'étape avant vos modifications. Faites un git merge --abort et vous reviendrez à l'étape précédente.
```console
git merge --abort
```
- Vous voulez analyser le merge effectué: éditez le/les fichiers en question.
  On va supposer que vous voulez garder le merge.
  On doit maintenant manuellement valider les merges(fusions) en éditant le fichier.
  Dans un merge il y a 5 parties:
   - le début (`<<<<<<< HEAD`),
   - Des modifications locales
   - une suite des caractères pour séparer les modifications locales et distantes: `=======`
   - Les modifications distantes.
   - la fin (`>>>>>>>`)
 
A vous de voir ce qui a lieu de garder dans les modifications. Une fois que c'est fait, vous devez aussi supprimer le `<<<<<<<` HEAD, les `======` et le `>>>>>>>>`
Vous enregistrez vos modifications. Vous ajoutez dans la zone d'index, vous commitez et vous poussez vos modifications sur GitHub.

Maintenant notre dépôt distant est à jour. Mais le dépôt B va avoir quelques problèmes car il va vouloir faire un git push qui va ne pas fonctionner car le dépôt A a déjà pushé ses modifs.

>   dépôt local A : C1(A) ===> C2(B) ===> C3(A) ===> C4(A)<br/>
>   GitHub : C1(A) ===> C2(B) ===> C3(A) ===> C4(A)<br/>
>   dépôt local B: C1(A) ===> C2(B) ===> C3(A) ===> C4(B)<br/>

Le dépôt B: fait un `git pull` mais constate qu'il y a un merge et qu'il devra faire un commit qui va compliquer la lecture de la branche master.

On fera un `git merge --abort`

On fera ensuite un `git pull --rebase` (comme ça le commit parent sera C4(A) et le commit du dépôt B deviendra C5(B)

>   dépôt local A : C1(A) ===> C2(B) ===> C3(A) ===> C4(A)<br/>
>   GitHub : C1(A) ===> C2(B) ===> C3(A) ===> C4(A)<br/>
>  dépôt local B: C1(A) ===> C2(B) ===> C3(A) ===> C4(A) ==> C5(B)<br/>

Mais en faisant ça, on auto merge donc à vous de vérifier ce qu'il y a lieu de faire avant de faire le commit C5(B) et le push.

>  dépôt local A : C1(A) ===> C2(B) ===> C3(A) ===> C4(A)<br/>
>  GitHub : C1(A) ===> C2(B) ===> C3(A) ===> C4(A) ==> C5(B)<br/>
>  dépôt local B: C1(A) ===> C2(B) ===> C3(A) ===> C4(A) ==> C5(B)<br/>

Et si le dépôt A fait un git pull:

>   dépôt local A : C1(A) ===> C2(B) ===> C3(A) ===> C4(A) ==> C5(B)<br/>
>   GitHub : C1(A) ===> C2(B) ===> C3(A) ===> C4(A) ==> C5(B)<br/>
>   dépôt local B: C1(A) ===> C2(B) ===> C3(A) ===> C4(A) ==> C5(B)






## 39. Github - Le format Markdown

GitHub permet l'affichage de fichiers Markdown. Markdown est un langage de balisage léger créé en 2004 par John Gruber avec l'aide d'Aaron Swartz. Son but est d'offrir une syntaxe facile à lire et à écrire. Un document balisé par Markdown peut être lu en l'état sans donner l’impression d'avoir été marqué par des balises ou des instructions de formatage, comme c'est le cas, par exemple, avec du texte enrichi (par exemple, du RTF ou du HTML).

Sa syntaxe est facile. Il suffit de mettre des caractères spéciaux pour mettre en forme notre texte.

Je vous ai mis dans ce dépôt un document pdf qui vous permettra de voir les possibilités de Markdown: [Markdown Cheatsheet (antisèche)](/pdf/markdown-cheatsheet-online.pdf).


### 39.1 Le fichier README.md
Ce fichier donne des informations sur le dépôt en question.

Quand vous avez créé un fichier README.md son contenu est directement affiché sur la page du dépôt. Un peu comme un index.html sur un site internet.

Ce fichier a une structure bien particulière est se base sur Markdown. Markdown permet de faire une belle mise en page.

L'étude de Markdown n'entre dans pas dans ce cours mais je vais vous donner quelques exemples car il permettra aux personnes qui regarderont votre dépôt de mieux comprendre votre projet via le fichier README.md ou tout autre fichier Markdown présent dans votre dépôt.

### 39.1 Mettre un titre h1

   On commence la ligne par un #

   ```markdown
   # Ceci est un titre 1

   ## Ceci est un titre 2
   ```

### 39.2 Afficher du code
   
   On utilise \`\`\`PHP avant notre code et après notre code \`\`\`. L'intérêt est d'avoir un affichage du code propre et avec une colorisation syntaxique.

   Exemple pour du code PHP:

   \`\`\`php<br>
   name = input("Quel est votre nom ?")<br>
   firstname = input("Quel est votre prenom ?")<br>
   \`\`\`

   Donnera le résultat suivant (voir le résultat sur github et pas via un pdf/html):

   ```php
   name = input("Quel est votre nom ?")
   firstname = input("Quel est votre prenom ?")
   ```
   On a plusieurs languages supportés: c, php, js, html, etc...

### 39.3 Mettre en gras

   On encadre avec `**` ou `__`ce qu'on veut mettre en gras.
   ```md
   Une **partie** de ce texte est en gras.
   ```
Une **partie** de ce texte est en gras.

### 39.4 Mettre en italic

   On encadre avec `_` ce qu'on veut mettre en italique.
   ```md
   Une _partie_ de ce texte est en italic.
   ```
   Une _partie_ de ce texte est en italic.

### 39.5 Liens hypertextes

   Il est courant de donner des liens hypertextes dans le fichier README.md

a. Mettre le lien directement: http://www.google.be
b. Mettre entre crochet notre texte décrivant le lien hypertext et notre lien entre parenthèses:
[Lien vers Google](http://www.google.be)
c. Description du lien avec un title quand on passe sur le lien. On ajoute alors un texte entre guillemets après l'url entre parenthèses:
[Lien vers Google](http://www.google.be "Allons sur Google !")
d. Pointer vers un fichier de notre dépôt. On peut simplement mettre le chemin du fichier dans le dépôt. Exemple ici: ./toto.txt pointe vers le fichier toto.txt du répertoire courant:
[Ce lien pointe vers un fichier de votre dépôt](./toto.txt)

```md
Exemples:
1. [Ce lien pointe vers un fichier de votre dépôt](./toto.txt)
2. Ce lien pointe vers [Google](http://www.google.be)
3. http://www.google.be
```

### 39.6 Les tableaux

   ```md
   Colonne 1|Colonne 2|Colonne 3
   ---|---|---
   Cellule 1|Cellule 2|Cellule 3
   Cellule 4|Cellule 5|Cellule 6
   Cellule 7|Cellule 8|Cellule 9
   ```
   Aura pour résultat:

   Colonne 1|Colonne 2|Colonne 3
   ---|---|---
   Cellule 1|Cellule 2|Cellule 3
   Cellule 4|Cellule 5|Cellule 6
   Cellule 7|Cellule 8|Cellule 9

On constate que pour faire un tableau, qu'il faut séparer le nom des colonnes par des `|`.

Ensuite on met autant de triple tirets `---` qu'on a de colonnes séparés par un `|`.

On a ensuite nos colonnes séparées par un `|`


## 40. Les GitHub Pages

Les GitHub Pages sont des pages web hébergées sur GitHub. Elles sont accessibles via l'url suivante: https://votreNomUtilisateur.github.io.

Pour créer une GitHub Page, il faut créer un dépôt public et le nommer: votreNomUtilisateur.github.io

Ensuite, vous pouvez créer un fichier index.html et le pousser sur GitHub. Vous pourrez alors accéder à votre page via l'url: https://votreNomUtilisateur.github.io ou bien-entendu via l'url du fichier index.html: https://votreNomUtilisateur.github.io/index.html

Alors, c'est très sympa mais il y a un problème du temps de mise à jour de la page. En effet, si vous modifiez votre fichier index.html et que vous le poussez sur GitHub, il peut s'écouler plusieurs minutes avant que votre page soit mise à jour. C'est un peu embêtant mais très pratique pour faire des démos ou faire une page de présentation de votre profil GitHub ou de votre projet.

Ca ne vaut pas un vrai hébergement mais c'est déjà pas mal et c'est gratuit. :-)

### 40.1 Créons le dépôt sur GitHub

#### A. Via le site GitHub
1. Allez sur cette page:[Create a new repository](https://github.com/new)
2. Dans le champ Repository name, mettez: github.io
3. Cliquer sur le bouton vert: Create repository.

#### B. Via gh
1. `gh repo create github.io --public`

### 40.2 Créons un dépôt local et poussons-le sur GitHub:
```bash
cd mesdepots
mkdir github.io
cd github.io
git init
```
Ajoutez le fichier index.html suivant:
```html
<!DOCTYPE html>
<html lang="fr-BE">
<head>
    <meta charset="UTF-8">
    <title>Ma page de démo</title>
</head>
<body>
    <h1>Ma page de démo</h1>
    <p>Voici ma première page web sur GitHub Pages.</p>
</body>
</html>
```
Reprenons les commandes:
```bash
git add index.html
git commit -m "first commit"
git remote add origin https://github.com/kikinorev/github.io.git
git push -u origin master
```
Allez sur votre page: https://votreNomUtilisateur.github.io


[:arrow_left: Revenir au sommaire.](../README.md#sommaire)

---
&copy; 2023 [Johnny Piette](https://github.com/ZamBoyle).  
[![Creative Commons Attribution 4.0 International License](https://i.creativecommons.org/l/by/4.0/88x31.png)](https://creativecommons.org/licenses/by/4.0/)  
Ce travail est licencié sous [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).   
_Vous pouvez copier, modifier, distribuer et représenter ce travail, même à des fins commerciales, à condition de donner le crédit approprié, fournir un lien vers la licence, et indiquer si des modifications ont été effectuées._